using System.Linq;
using static Cubing.ThreeByThree.Constants;

namespace Cubing.ThreeByThree.TwoPhase
{
    /// <summary>
    /// Contains move tables used to accelerate the process of applying
    /// moves to a cube. Uses the coordinates generated by
    /// <see cref="Coordinates"/>.
    /// </summary>
    public static class MoveTables
    {
        /// <summary>
        /// <c><see cref="Phase1IndexToPhase2Index"/>[m]</c>, where <c>m</c> is
        /// the index of a phase 1 move, contains the index of the same move
        /// used in phase 2. If the move is not used in phase 2, the value
        /// stored is <c>-1</c>.
        /// </summary>
        public static int[] Phase1IndexToPhase2Index = new int[] {
            -1, 0, -1, // R, R2, R'
             1, 2,  3, // U, U2, U'
            -1, 4, -1, // F, F2, F'
            -1, 5, -1, // L, L2, L'
             6, 7,  8, // D, D2, D'
            -1, 9, -1  // B, B2, B'
        };

        /// <summary>
        /// <c><see cref="Phase2IndexToPhase1Index"/>[m]</c>, where <c>m</c> is
        /// the index of a phase 2 move, contains the index of the same move
        /// used in phase 1.
        /// </summary>
        public static int[] Phase2IndexToPhase1Index = new int[]
        {
             1,  3,  4,  5,  7, // R2, U, U2, U', F2
            10, 12, 13, 14, 16  // L2, D, D2, D', B2
        };

        /// <summary>
        /// Create a move table for the corner orientation of a 3x3x3.
        /// </summary>
        /// <returns>
        /// A move table for the corner orientation of a 3x3x3.
        /// </returns>
        public static short[,] CreateCoMoveTable()
        {
            CubieCube cube = CubieCube.CreateSolved();
            short[,] coMoveTable = new short[Coordinates.NumCoCoords, NumMoves];

            for (int co = 0; co < Coordinates.NumCoCoords; co++)
                for (int move = 0; move < NumMoves; move++)
                    coMoveTable[co, move] = -1;

            for (int co = 0; co < Coordinates.NumCoCoords; co++)
                for (int face = 0; face < NumFaces; face++)
                {
                    Coordinates.SetCoCoord(cube, co);
                    for (int move = 0; move < 3; move++)
                    {
                        cube.MultiplyCorners(CubieCube.MovesArray[face * 3]);
                        coMoveTable[co, face * 3 + move] = (short)Coordinates.GetCoCoord(cube);
                    }
                }

            return coMoveTable;
        }

        /// <summary>
        /// Create a move table for the edge orientation of a 3x3x3.
        /// </summary>
        /// <returns>
        /// A move table for the edge orientation of a 3x3x3.
        /// </returns>
        public static short[,] CreateEoMoveTable()
        {
            CubieCube cube = CubieCube.CreateSolved();
            short[,] eoMoveTable = new short[Coordinates.NumEoCoords, NumMoves];

            for (int eo = 0; eo < Coordinates.NumEoCoords; eo++)
                for (int move = 0; move < NumMoves; move++)
                    eoMoveTable[eo, move] = -1;

            for (int eo = 0; eo < Coordinates.NumEoCoords; eo++)
                for (int face = 0; face < NumFaces; face++)
                {
                    Coordinates.SetEoCoord(cube, eo);
                    for (int move = 0; move < 3; move++)
                    {
                        cube.MultiplyEdges(CubieCube.MovesArray[face * 3]);
                        eoMoveTable[eo, face * 3 + move] = (short)Coordinates.GetEoCoord(cube);
                    }
                }

            return eoMoveTable;
        }

        /// <summary>
        /// Create a move table for the equator distribution of a 3x3x3 cube.
        /// </summary>
        /// <returns>
        /// A move table for the equator distribution of a 3x3x3 cube.
        /// </returns>
        public static short[,] CreateEquatorDistributionMoveTable()
        {
            CubieCube cube = CubieCube.CreateSolved();
            short[,] equatorDistributionMoveTable = new short[Coordinates.NumEquatorDistributionCoords, NumMoves];

            for (int equatorDistribution = 0; equatorDistribution < Coordinates.NumEquatorDistributionCoords; equatorDistribution++)
                for (int move = 0; move < NumMoves; move++)
                    equatorDistributionMoveTable[equatorDistribution, move] = -1;

            for (int equatorDistribution = 0; equatorDistribution < Coordinates.NumEquatorDistributionCoords; equatorDistribution++)
                for (int face = 0; face < NumFaces; face++)
                {
                    Coordinates.SetEquatorDistributionCoord(cube, equatorDistribution);
                    for (int qt = 0; qt < 3; qt++)
                    {
                        cube.MultiplyEdges(CubieCube.MovesArray[face * 3]);
                        equatorDistributionMoveTable[equatorDistribution, face * 3 + qt] = (short)Coordinates.GetEquatorDistributionCoord(cube);
                    }
                }

            return equatorDistributionMoveTable;
        }

        /// <summary>
        /// Create a move table for the equator permutation of a 3x3x3 cube.
        /// </summary>
        /// <returns>
        /// A move table for the equator permutation of a 3x3x3 cube.
        /// </returns>
        public static sbyte[,] CreateEquatorPermutationMoveTable()
        {
            sbyte[,] equatorPermutationMoveTable = new sbyte[Coordinates.NumEquatorPermutationCoords, NumMoves];

            for (int equatorPermutation = 0; equatorPermutation < Coordinates.NumEquatorPermutationCoords; equatorPermutation++)
                for (int move = 0; move < NumMoves; move++)
                    equatorPermutationMoveTable[equatorPermutation, move] = -1;

            for (int equatorPermutation = 0; equatorPermutation < Coordinates.NumEquatorPermutationCoords; equatorPermutation++)
                for (int face = 0; face < NumFaces; face++)
                {
                    CubieCube cube = CubieCube.CreateSolved();
                    Coordinates.SetEquatorPermutationCoord(cube, equatorPermutation);
                    for (int qt = 0; qt < 3; qt++)
                    {
                        cube.MultiplyEdges(CubieCube.MovesArray[face * 3]);
                        if (TwoPhaseConstants.Phase2Moves.Contains((Move)(face * 3 + qt)))
                            equatorPermutationMoveTable[equatorPermutation, face * 3 + qt] = (sbyte)Coordinates.GetEquatorPermutationCoord(cube);
                    }
                }

            return equatorPermutationMoveTable;
        }


        /// <summary>
        /// Create a move table for the equator distribution and permutation of
        /// a 3x3x3 cube.
        /// </summary>
        /// <returns>
        /// A move table for the equator distribution and permutation of a
        /// 3x3x3 cube.
        /// </returns>
        public static short[,] CreateEquatorMoveTable()
        {
            CubieCube cube = CubieCube.CreateSolved();
            short[,] equatorMoveTable = new short[Coordinates.NumEquatorCoords, NumMoves];

            for (int equator = 0; equator < Coordinates.NumEquatorCoords; equator++)
                for (int move = 0; move < NumMoves; move++)
                    equatorMoveTable[equator, move] = -1;

            for (int equator = 0; equator < Coordinates.NumEquatorCoords; equator++)
                for (int face = 0; face < NumFaces; face++)
                {
                    Coordinates.SetEquatorCoord(cube, equator);
                    for (int qt = 0; qt < 3; qt++)
                    {
                        cube.MultiplyEdges(CubieCube.MovesArray[face * 3]);
                        equatorMoveTable[equator, face * 3 + qt] = (short)Coordinates.GetEquatorCoord(cube);
                    }
                }

            return equatorMoveTable;
        }

        /// <summary>
        /// Create a move table for the corner permutation of a 3x3x3.
        /// </summary>
        /// <returns>
        /// A move table for the corner permutation of a 3x3x3.
        /// </returns>
        public static ushort[,] CreateCpMoveTable()
        {
            CubieCube cube = CubieCube.CreateSolved();
            ushort[,] cpMoveTable = new ushort[Coordinates.NumCpCoords, NumMoves];

            //invalidate table
            for (int cp = 0; cp < Coordinates.NumCpCoords; cp++)
                for (int move = 0; move < NumMoves; move++)
                    cpMoveTable[cp, move] = ushort.MaxValue;

            //populate table
            for (int cp = 0; cp < Coordinates.NumCpCoords; cp++)
                for (int face = 0; face < NumFaces; face++)
                {
                    Coordinates.SetCpCoord(cube, cp);
                    for (int move = 0; move < 3; move++)
                    {
                        cube.MultiplyCorners(CubieCube.MovesArray[face * 3]);
                        cpMoveTable[cp, face * 3 + move] = (ushort)Coordinates.GetCpCoord(cube);
                    }
                }

            return cpMoveTable;
        }

        public static short[,] CreateUEdgesMoveTable()
        {
            CubieCube cube = CubieCube.CreateSolved();
            short[,] uEdgeMoveTable = new short[Coordinates.NumUEdgeCoordsPhase1, NumMoves];

            //invalidate table
            for (int uEdges = 0; uEdges < Coordinates.NumUEdgeCoordsPhase1; uEdges++)
                for (int move = 0; move < NumMoves; move++)
                    uEdgeMoveTable[uEdges, move] = -1;

            //populate table
            for (int uEdges = 0; uEdges < Coordinates.NumUEdgeCoordsPhase1; uEdges++)
                for (int face = 0; face < NumFaces; face++)
                {
                    Coordinates.SetUEdgeCoord(cube, uEdges);
                    for (int qt = 0; qt < 3; qt++)
                    {
                        cube.MultiplyEdges(CubieCube.MovesArray[face * 3]);
                        uEdgeMoveTable[uEdges, face * 3 + qt] = (short)Coordinates.GetUEdgeCoord(cube);
                    }
                }

            return uEdgeMoveTable;
        }
        
        public static short[,] CreateDEdgesMoveTable()
        {
            CubieCube cube = CubieCube.CreateSolved();
            short[,] dEdgeMoveTable = new short[Coordinates.NumDEdgeCoordsPhase1, NumMoves];

            //invalidate table
            for (int dEdges = 0; dEdges < Coordinates.NumDEdgeCoordsPhase1; dEdges++)
                for (int move = 0; move < NumMoves; move++)
                    dEdgeMoveTable[dEdges, move] = -1;

            //populate table
            for (int dEdges = 0; dEdges < Coordinates.NumDEdgeCoordsPhase1; dEdges++)
                for (int face = 0; face < NumFaces; face++)
                {
                    Coordinates.SetDEdgeCoord(cube, dEdges);
                    for (int qt = 0; qt < 3; qt++)
                    {
                        cube.MultiplyEdges(CubieCube.MovesArray[face * 3]);
                        dEdgeMoveTable[dEdges, face * 3 + qt] = (short)Coordinates.GetDEdgeCoord(cube);
                    }
                }

            return dEdgeMoveTable;
        }

        public static ushort[,] CreateUdEdgePermutationMoveTable()
        {
            ushort[,] udEdgePermutationMoveTable = new ushort[Coordinates.NumUdEdgePermutationCoords, TwoPhaseConstants.NumMovesPhase2];

            //invalidate table
            for (int udEdgePermutation = 0; udEdgePermutation < Coordinates.NumUdEdgePermutationCoords; udEdgePermutation++)
                for (int move = 0; move < TwoPhaseConstants.NumMovesPhase2; move++)
                    udEdgePermutationMoveTable[udEdgePermutation, move] = ushort.MaxValue;

            //populate table
            for (int udEdgePermutation = 0; udEdgePermutation < Coordinates.NumCpCoords; udEdgePermutation++)
                for (int face = 0; face < NumFaces; face++)
                {
                    CubieCube cube = CubieCube.CreateSolved();
                    Coordinates.SetUdEdgePermutationCoord(cube, udEdgePermutation);
                    for (int move = 0; move < 3; move++)
                    {
                        cube.MultiplyEdges(CubieCube.MovesArray[face * 3]);
                        if (TwoPhaseConstants.Phase2Moves.Contains((Move)(face * 3 + move)))
                            udEdgePermutationMoveTable[udEdgePermutation, Phase1IndexToPhase2Index[face * 3 + move]] = (ushort)Coordinates.GetUdEdgePermutationCoord(cube);
                    }
                }

            return udEdgePermutationMoveTable;
        }
    }
}