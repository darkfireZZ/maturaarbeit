using static Cubing.ThreeByThree.Constants;
using System.Linq;

namespace Cubing.ThreeByThree.TwoPhase
{
    /// <summary>
    /// Contains move tables used to accelerate the process of applying
    /// moves to a cube. Uses the coordinates generated by
    /// <see cref="Coordinates"/>.
    /// </summary>
    public static class MoveTables
    {
        /// <summary>
        /// Create a move table for the corner orientation of a 3x3x3.
        /// </summary>
        /// <returns>
        /// A move table for the corner orientation of a 3x3x3.
        /// </returns>
        public static short[,] CreateCoMoveTable()
        {
            CubieCube cube = CubieCube.CreateSolved();
            short[,] coMoveTable = new short[Coordinates.NumCoCoords, NumMoves];

            for (int co = 0; co < Coordinates.NumCoCoords; co++)
                for (int move = 0; move < NumMoves; move++)
                    coMoveTable[co, move] = -1;

            for (int co = 0; co < Coordinates.NumCoCoords; co++)
                for (int face = 0; face < NumFaces; face++)
                {
                    Coordinates.SetCoCoord(cube, co);
                    for (int move = 0; move < 3; move++)
                    {
                        cube.MultiplyCorners(CubieCube.MovesArray[face * 3]);
                        coMoveTable[co, face * 3 + move] = (short)Coordinates.GetCoCoord(cube);
                    }
                }

            return coMoveTable;
        }

        /// <summary>
        /// Create a move table for the edge orientation of a 3x3x3.
        /// </summary>
        /// <returns>
        /// A move table for the edge orientation of a 3x3x3.
        /// </returns>
        public static short[,] CreateEoMoveTable()
        {
            CubieCube cube = CubieCube.CreateSolved();
            short[,] eoMoveTable = new short[Coordinates.NumEoCoords, NumMoves];

            for (int eo = 0; eo < Coordinates.NumEoCoords; eo++)
                for (int move = 0; move < NumMoves; move++)
                    eoMoveTable[eo, move] = -1;

            for (int eo = 0; eo < Coordinates.NumEoCoords; eo++)
                for (int face = 0; face < NumFaces; face++)
                {
                    Coordinates.SetEoCoord(cube, eo);
                    for (int move = 0; move < 3; move++)
                    {
                        cube.MultiplyEdges(CubieCube.MovesArray[face * 3]);
                        eoMoveTable[eo, face * 3 + move] = (short)Coordinates.GetEoCoord(cube);
                    }
                }

            return eoMoveTable;
        }

        /// <summary>
        /// Create a move table for the equator distribution of a 3x3x3 cube.
        /// </summary>
        /// <returns>
        /// A move table for the equator distribution of a 3x3x3 cube.
        /// </returns>
        public static short[,] CreateEquatorDistributionMoveTable()
        {
            CubieCube cube = CubieCube.CreateSolved();
            short[,] equatorDistributionMoveTable = new short[Coordinates.NumEquatorDistributionCoords, NumMoves];

            for (int equatorDistribution = 0; equatorDistribution < Coordinates.NumEquatorDistributionCoords; equatorDistribution++)
                for (int move = 0; move < NumMoves; move++)
                    equatorDistributionMoveTable[equatorDistribution, move] = -1;

            for (int equatorDistribution = 0; equatorDistribution < Coordinates.NumEquatorDistributionCoords; equatorDistribution++)
                for (int face = 0; face < NumFaces; face++)
                {
                    Coordinates.SetEquatorDistributionCoord(cube, equatorDistribution);
                    for (int qt = 0; qt < 3; qt++)
                    {
                        cube.MultiplyEdges(CubieCube.MovesArray[face * 3]);
                        equatorDistributionMoveTable[equatorDistribution, face * 3 + qt] = (short)Coordinates.GetEquatorDistributionCoord(cube);
                    }
                }

            return equatorDistributionMoveTable;
        }

        /// <summary>
        /// Create a move table for the equator permutation of a 3x3x3 cube.
        /// </summary>
        /// <returns>
        /// A move table for the equator permutation of a 3x3x3 cube.
        /// </returns>
        public static sbyte[,] CreateEquatorPermutationMoveTable()
        {
            CubieCube cube = CubieCube.CreateSolved();
            sbyte[,] equatorPermutationMoveTable = new sbyte[Coordinates.NumEquatorPermutationCoords, NumMoves];

            for (int equatorPermutation = 0; equatorPermutation < Coordinates.NumEquatorPermutationCoords; equatorPermutation++)
                for (int move = 0; move < NumMoves; move++)
                    equatorPermutationMoveTable[equatorPermutation, move] = -1;

            for (int equatorPermutation = 0; equatorPermutation < Coordinates.NumEquatorPermutationCoords; equatorPermutation++)
                for (int face = 0; face < NumFaces; face++)
                {
                    cube = CubieCube.CreateSolved();
                    Coordinates.SetEquatorPermutationCoord(cube, equatorPermutation);
                    for (int qt = 0; qt < 3; qt++)
                    {
                        cube.MultiplyEdges(CubieCube.MovesArray[face * 3]);
                        if (TwoPhaseConstants.Phase2Moves.Contains((Move)(face * 3 + qt)))
                            equatorPermutationMoveTable[equatorPermutation, face * 3 + qt] = (sbyte)Coordinates.GetEquatorPermutationCoord(cube);
                    }
                }

            return equatorPermutationMoveTable;
        }

        /// <summary>
        /// Create a move table for the corner permutation of a 3x3x3.
        /// </summary>
        /// <returns>
        /// A move table for the corner permutation of a 3x3x3.
        /// </returns>
        public static ushort[,] CreateCpMoveTable()
        {
            CubieCube cube = CubieCube.CreateSolved();
            ushort[,] cpMoveTable = new ushort[Coordinates.NumCpCoords, NumMoves];

            //invalidate table
            for (int cp = 0; cp < Coordinates.NumCpCoords; cp++)
                for (int move = 0; move < NumMoves; move++)
                    cpMoveTable[cp, move] = ushort.MaxValue;

            //populate table
            for (int cp = 0; cp < Coordinates.NumCpCoords; cp++)
                for (int face = 0; face < NumFaces; face++)
                {
                    Coordinates.SetCpCoord(cube, cp);
                    for (int move = 0; move < 3; move++)
                    {
                        cube.MultiplyCorners(CubieCube.MovesArray[face * 3]);
                        cpMoveTable[cp, face * 3 + move] = (ushort)Coordinates.GetCpCoord(cube);
                    }
                }

            return cpMoveTable;
        }

        //IMPR space efficiency
        public static ushort[,] CreateUdEdgePermutationMoveTable()
        {
            CubieCube cube = CubieCube.CreateSolved();
            ushort[,] udEdgePermutationMoveTable = new ushort[Coordinates.NumUdEdgePermutationCoords, NumMoves];

            //invalidate table
            for (int udEdgePermutation = 0; udEdgePermutation < Coordinates.NumUdEdgePermutationCoords; udEdgePermutation++)
                for (int move = 0; move < NumMoves; move++)
                    udEdgePermutationMoveTable[udEdgePermutation, move] = ushort.MaxValue;

            //populate table
            for (int udEdgePermutation = 0; udEdgePermutation < Coordinates.NumCpCoords; udEdgePermutation++)
                for (int face = 0; face < NumFaces; face++)
                {
                    Coordinates.SetUdEdgePermutationCoord(cube, udEdgePermutation);
                    for (int move = 0; move < 3; move++)
                    {
                        cube.MultiplyEdges(CubieCube.MovesArray[face * 3]);
                        if (TwoPhaseConstants.Phase2Moves.Contains((Move)(face * 3 + move)))
                            udEdgePermutationMoveTable[udEdgePermutation, face * 3 + move] = (ushort)Coordinates.GetUdEdgePermutationCoord(cube);
                    }
                }

            return udEdgePermutationMoveTable;
        }
    }
}