using System;
using System.Linq;
using static Cubing.ThreeByThree.Constants;
using static Cubing.ThreeByThree.Coordinates;

namespace Cubing.ThreeByThree.TwoPhase
{
    /// <summary>
    /// Contains pruning tables used to accelerate the solving of a cube.
    /// Uses the coordinates generated by <see cref="Coordinates"/>.
    /// </summary>
    public static class PruningTables
    {

        //IMPR performance
        /// <summary>
        /// Create the pruning table for phase 1.
        /// </summary>
        /// <returns></returns>
        public static byte[] CreatePhase1Table()
        {
            byte invalid = 255;

            byte[] pruningTable = Enumerable
                .Repeat(invalid, TwoPhaseConstants.PruningTableSizePhase1)
                .ToArray();
            pruningTable[0] = 0; //solved

            TableController.InitializeCoMoveTable();
            TableController.InitializeEoMoveTable();
            TableController.InitializeEquatorDistributionMoveTable();

            int done = 1;
            int depth = 0;

            string outputFormat = "depth: {0}, done: {1}/" + TwoPhaseConstants.PruningTableSizePhase1 + " ({2:P})";
            Console.WriteLine(string.Format(outputFormat, depth, done, done / (double)TwoPhaseConstants.PruningTableSizePhase1));

            while (done < TwoPhaseConstants.PruningTableSizePhase1)
            {
                for (int reducedEoEquator = 0; reducedEoEquator < TwoPhaseConstants.NumReducedEoEquatorCoordinates; reducedEoEquator++)
                    for (int co = 0; co < NumCoCoords; co++)
                    {
                        int index = NumCoCoords * reducedEoEquator + co;
                        if (pruningTable[index] == depth)
                        {
                            int expandedEoEquator = Phase1Tables.ExpandEoEquatorCoordinate[reducedEoEquator];
                            int eo = expandedEoEquator % NumEoCoords;
                            int equator = expandedEoEquator / NumEoCoords;
                            for (int move = 0; move < NumMoves; move++)
                            {
                                //apply move
                                int newCo = TableController.CoMoveTable[co, move];
                                int newEo = TableController.EoMoveTable[eo, move];
                                int newEquator = TableController.EquatorDistributionMoveTable[equator, move];
                                //same as calling 
                                //GetPruningCoord(newCo, newEo, newEquator),
                                //but the reduced eo-equator coordinate is
                                //required.
                                int newExpandedEoEquator = newEquator * NumEoCoords + newEo;
                                int newReducedEoEquator = Phase1Tables.ReduceEoEquatorCoordinate[newExpandedEoEquator];
                                int reductionSymmetry = Phase1Tables.ReductionSymmetry[newExpandedEoEquator];
                                newCo = Phase1Tables.ConjugateCoCoordinate[newCo, reductionSymmetry];
                                int newIndex = newReducedEoEquator * NumCoCoords + newCo;

                                //store depth
                                if (pruningTable[newIndex] == invalid)
                                {
                                    pruningTable[newIndex] = (byte)(depth + 1);
                                    done++;

                                    //TODO understand why necessary
                                    int flags = Phase1Tables.ReducedEoEquatorCoordinateSymmetries[newReducedEoEquator];
                                    for (int symmetry = 1; symmetry < TwoPhaseConstants.NumSymmetriesPhase1; symmetry++)
                                    {
                                        flags >>= 1;
                                        if ((flags & 0x0001) == 1)
                                        {
                                            int rotatedCo = Phase1Tables.ConjugateCoCoordinate[newCo, symmetry];
                                            int rotatedIndex = NumCoCoords * newReducedEoEquator + rotatedCo;
                                            if (pruningTable[rotatedIndex] == invalid)
                                            {
                                                pruningTable[rotatedIndex] = (byte)(depth + 1);
                                                done++;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                depth++;
                Console.WriteLine(string.Format(outputFormat, depth, done, done / (double)TwoPhaseConstants.PruningTableSizePhase1));
            }
            return pruningTable;
        }

        /// <summary>
        /// Create the pruning table for phase 2.
        /// </summary>
        /// <returns></returns>
        public static byte[] CreatePhase2Table()
        {
            byte invalid = 255;

            byte[] pruningTable = Enumerable
                .Repeat(invalid, TwoPhaseConstants.PruningTableSizePhase2)
                .ToArray();

            TableController.InitializeCpMoveTable();
            TableController.InitializeEquatorPermutationMoveTable();

            pruningTable[0] = 0;
            int done = 1;
            int depth = 0;

            string outputFormat = "depth: {0}, done: {1}/" + TwoPhaseConstants.PruningTableSizePhase2 + " ({2:P})";
            Console.WriteLine(string.Format(outputFormat, depth, done, done / (double)TwoPhaseConstants.PruningTableSizePhase2));

            while (done < TwoPhaseConstants.PruningTableSizePhase2)
            {
                for (int cp = 0; cp < Coordinates.NumCpCoords; cp++)
                {
                    for (int equatorPermutation = 0; equatorPermutation < TwoPhaseConstants.NumEquatorPermutations; equatorPermutation++)
                    {
                        int index = TwoPhaseConstants.NumEquatorPermutations * cp + equatorPermutation;
                        if (pruningTable[index] == depth)
                        {
                            foreach (int move in TwoPhaseConstants.Phase2Moves)
                            {
                                int newCp = TableController.CpMoveTable[cp, move];
                                int newEquatorPerm = TableController.EquatorPermutationMoveTable[equatorPermutation, move];
                                int newIndex = TwoPhaseConstants.NumEquatorPermutations * newCp + newEquatorPerm;

                                if (pruningTable[newIndex] == invalid)
                                {
                                    pruningTable[newIndex] = (byte)(depth + 1);
                                    done++;
                                }
                            }
                        }
                    }
                }
                depth++;
                Console.WriteLine(string.Format(outputFormat, depth, done, done / (double)TwoPhaseConstants.PruningTableSizePhase2));
            }

            return pruningTable;
        }
    }
}