using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;

namespace Cubing
{
    //MAYBE not throw FormatExcpetion in some cases
    //TEST (more tests)
    //TODO add time splits functionality
    /// <summary>
    /// Gives functionality to read, edit and write data of a CSV file
    /// generated by csTimer.
    /// </summary>
    public class CsTimerData
    {
        /// <summary>
        /// Create a new CsTimerData object.
        /// </summary>
        /// <remarks>
        /// It is suggested to use a member initializer fro initializing
        /// all the properties.
        /// </remarks>
        public CsTimerData() { }

        /// <summary>
        /// The index of the solve
        /// </summary>
        public int Number { get; set; }
        /// <summary>
        /// The time of the solve in milliseconds
        /// </summary>
        public int Milliseconds { get; set; }
        /// <summary>
        /// The type of penalty for the solve as a
        /// <see cref="CubingPenalty"/> enum.
        /// </summary>
        public CubingPenalty Penalty { get; set; } = CubingPenalty.Okay;
        /// <summary>
        /// Any comment of the solve
        /// </summary>
        public string Comment { get; set; } = "";
        /// <summary>
        /// The scramble for the solve
        /// </summary>
        public string Scramble { get; set; }
        /// <summary>
        /// The date of the solve. Null if the time is not known.
        /// </summary>
        public DateTime? Date { get; set; } = null;

        //TODO edit filenotfoundexception description
        /// <summary>
        /// Iterate through every solve in a csTimer CSV file and perform
        /// an action on it.
        /// </summary>
        /// <remarks>
        /// The first line of the file is ignored. The file suffix does
        /// not have to be .csv. It can be any type of file as long as its
        /// content has the right format.
        /// </remarks>
        /// <param name="path">
        /// The path to the CSV file.
        /// </param>
        /// <param name="action">
        /// The action to perform for each solve in the file.
        /// </param>
        /// <exception cref="ArgumentException">
        /// Thrown if <paramref name="path"/> is an empty string (""), contains only white
        /// space, or contains one or more invalid characters. -or- path
        /// refers to a non-file device, such as "con:", "com1:", "lpt1:",
        /// etc. in an NTFS environment.
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// Thrown if path refers to a non-file device, such as "con:",
        /// "com1:", "lpt1:", etc. in a non-NTFS environment.
        /// </exception>
        /// <exception cref="ArgumentNullException">
        /// Thrown if <paramref name="path"/> or <paramref name="action"/>
        /// is null.
        /// </exception>
        /// <exception cref="System.Security.SecurityException">
        /// Thrown if the caller does not have the required permission.
        /// </exception>
        /// <exception cref="FileNotFoundException">
        /// Thrown if the file cannot be found, such as when mode is
        /// FileMode.Truncate or FileMode.Open, and the file specified by
        /// path does not exist. The file must already exist in these
        /// modes.
        /// </exception>
        /// <exception cref="UnauthorizedAccessException">
        /// Thrown if <paramref name="path"/> specifies a file that is read-only.
        /// </exception>
        /// <exception cref="IOException">
        /// Thrown if an I/O error occurs.
        /// </exception>
        /// <exception cref="DirectoryNotFoundException">
        /// Thrown if the specified path is invalid, such as being on an
        /// unmapped drive.
        /// </exception>
        /// <exception cref="PathTooLongException">
        /// Thrown if the specified path, file name, or both exceed the
        /// system-defined maximum length.
        /// </exception>
        /// <exception cref="OutOfMemoryException">
        /// Thrown if there is insufficient memory to allocate a buffer
        /// for the next line.
        /// </exception>
        /// <exception cref="FormatException">
        /// Thrown if the file has an illegal format.
        /// </exception>
        public static void ReadCsTimerData(string path, Action<CsTimerData> action)
        {
            if (path is null)
                throw new ArgumentNullException(nameof(path) + " is null.");
            if (action is null)
                throw new ArgumentNullException(nameof(action) + " is null.");

            using (StreamReader reader = new StreamReader(new FileStream(path, FileMode.Open)))
            {
                reader.ReadLine(); //skip line with headers
                string currentLine = null;
                while ((currentLine = reader.ReadLine()) != null)
                {
                    try
                    {
                        string[] values = currentLine.Split(';');
                        var (milliseconds, penalty) = SplitTimeAndPenalty(values[1]);
                        action(
                            new CsTimerData()
                            {
                                Number = int.Parse(values[0]),
                                Milliseconds = milliseconds,
                                Penalty = penalty,
                                Comment = values[2],
                                Scramble = values[3],
                                Date = values[4] == "N/A" ? null : (DateTime?)DateTime.Parse(values[4])
                            }
                        );
                    }
                    catch(Exception exception)
                    {
                        if (exception is ArgumentException || exception is FormatException)
                            throw new FormatException("The line has an illegal format: " + currentLine, exception);
                        throw;
                    }
                }
            }
        }

        //TODO edit filenotfoundexception description
        //TODO find out if file is really deleted when it already exists.
        /// <summary>
        /// Write every element in an enumerable to a CSV file.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If there is a file at the path specified, it is deleted.
        /// </para>
        /// <para>
        /// If the comment or the scramble of an element is null, an empty
        /// string is written to the file.
        /// </para>
        /// </remarks>
        /// <param name="path">The path to create the file at</param>
        /// <param name="enumerable">
        /// All the solves to write to the file
        /// </param>
        /// /// <exception cref="ArgumentException">
        /// Thrown if <paramref name="path"/> is an empty string (""), contains only white
        /// space, or contains one or more invalid characters. -or- path
        /// refers to a non-file device, such as "con:", "com1:", "lpt1:",
        /// etc. in an NTFS environment.
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// Thrown if path refers to a non-file device, such as "con:",
        /// "com1:", "lpt1:", etc. in a non-NTFS environment.
        /// </exception>
        /// <exception cref="ArgumentNullException">
        /// Thrown if <paramref name="path"/> or <paramref name="enumerable"/> is null.
        /// </exception>
        /// <exception cref="System.Security.SecurityException">
        /// Thrown if the caller does not have the required permission.
        /// </exception>
        /// <exception cref="FileNotFoundException">
        /// Thrown if the file cannot be found, such as when mode is
        /// FileMode.Truncate or FileMode.Open, and the file specified by
        /// path does not exist. The file must already exist in these
        /// modes.
        /// </exception>
        /// <exception cref="UnauthorizedAccessException">
        /// Thrown if <paramref name="path"/> specifies a file that is read-only.
        /// </exception>
        /// <exception cref="IOException">
        /// Thrown if an I/O error occurs.
        /// </exception>
        /// <exception cref="DirectoryNotFoundException">
        /// Thrown if the specified path is invalid, such as being on an
        /// unmapped drive.
        /// </exception>
        /// <exception cref="PathTooLongException">
        /// Thrown if the specified path, file name, or both exceed the
        /// system-defined maximum length.
        /// </exception>
        /// <exception cref="FormatException">
        /// Thrown if the Milliseconds property of an element in
        /// <paramref name="enumerable"/> specifies a
        /// <see cref="TimeSpan"/> value less than
        /// <see cref="TimeSpan.MinValue"/> or greater than
        /// <see cref="TimeSpan.MaxValue"/>.
        /// </exception>
        public static void WriteCsTimerData(string path, IEnumerable<CsTimerData> enumerable)
        {
            if (path is null)
                throw new ArgumentNullException(nameof(path) + " is null.");
            if (enumerable is null)
                throw new ArgumentNullException(nameof(enumerable) + " is null.");

            using (StreamWriter writer = new StreamWriter(new FileStream(path, FileMode.Create)))
            {
                writer.Write("No.;Time;Comment;Scramble;Date;P.1"); //write header
                foreach (var data in enumerable) //write all data
                    writer.Write("\n" + data.ToString(separator: ";"));
            }
        }

        /// <summary>
        /// Formats a time in milliseconds and a
        /// <see cref="CubingPenalty"/> enum to a string like csTimer
        /// uses it.
        /// </summary>
        /// <remarks>
        /// Use <seealso cref="SplitTimeAndPenalty(string)"/> to extract a
        /// time and a penalty from a string.
        /// </remarks>
        /// <param name="milliseconds">
        /// The solve time in milliseconds
        /// </param>
        /// <param name="penalty">The penalty</param>
        /// <returns>A string in the format used by csTimer</returns>
        /// <seealso cref="SplitTimeAndPenalty(string)"/>
        /// <exception cref="ArgumentOutOfRangeException">
        /// Thrown if milliseconds specifies a <see cref="TimeSpan"/>
        /// value less than <see cref="TimeSpan.MinValue"/> or greater
        /// than <see cref="TimeSpan.MaxValue"/>.
        /// </exception>
        public static string CombineTimeAndPenalty(int milliseconds, CubingPenalty penalty)
        {
            switch (penalty)
            {
                case CubingPenalty.Okay:
                    return MillisecondsToCsTimerFormat(milliseconds);
                case CubingPenalty.PlusTwo:
                    return MillisecondsToCsTimerFormat(milliseconds + 2000) + "+";
                case CubingPenalty.DidNotFinish:
                    return "DNF(" + MillisecondsToCsTimerFormat(milliseconds) + ")";
                default:
                    throw new NotSupportedException("This code should not be reachable");
            }
        }

        /// <summary>
        /// Extract the time in milliseconds and the penalty from a string
        /// where the two are combined in the format of csTimer.
        /// </summary>
        /// <remarks>
        /// Use
        /// <seealso cref="CombineTimeAndPenalty(int, CubingPenalty)"/>
        /// to combine a time and a penalty.
        /// </remarks>
        /// <param name="timeAndPenalty">
        /// The string to extract time and penalty from
        /// </param>
        /// <returns>
        /// A named tuple containing a time in milliseconds with the name
        /// milliseconds and a  <see cref="CubingPenalty"/> with the name
        /// penalty.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// Thrown if <paramref name="timeAndPenalty"/> is null.
        /// </exception>
        /// <exception cref="FormatException">
        /// Thrown if <paramref name="timeAndPenalty"/> has an invalid
        /// format.
        /// </exception>
        public static (int milliseconds, CubingPenalty penalty) SplitTimeAndPenalty(string timeAndPenalty)
        {
            try
            {
                if (timeAndPenalty is null)
                    throw new ArgumentNullException(nameof(timeAndPenalty) + " is null.");
                if (timeAndPenalty.EndsWith("+")) //+2 penalty
                    return (CsTimerFormatToMilliseconds(timeAndPenalty.Substring(0, timeAndPenalty.Length - 1)) - 2000, CubingPenalty.PlusTwo);
                if (timeAndPenalty.StartsWith("DNF(") && timeAndPenalty.EndsWith(")")) //DNF penalty
                    return (CsTimerFormatToMilliseconds(timeAndPenalty.Substring(4, timeAndPenalty.Length - 5)), CubingPenalty.DidNotFinish);
                //else //no penalty
                return (CsTimerFormatToMilliseconds(timeAndPenalty), CubingPenalty.Okay);
            }
            catch(FormatException exception)
            {
                throw new FormatException(nameof(timeAndPenalty) + " has an invalid format: " + timeAndPenalty, exception);
            }
        }

        //TODO test if really throw outofrangeexception else change in all occurrences
        //TODO check format
        /// <summary>
        /// Transform a time in milliseconds to a string in the format of
        /// csTimer.
        /// </summary>
        /// <remarks>
        /// <para>csTimer uses the format HH:MM:SS.mmm.</para>
        /// Use <seealso cref="CsTimerFormatToMilliseconds(string)"/> to
        /// transform a string to a time in milliseconds.
        /// </remarks>
        /// <param name="milliseconds">
        /// The time in milliseconds to be transformed
        /// </param>
        /// <returns>
        /// The time as string in the format specified in the remarks
        /// section
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// Thrown if milliseconds specifies a <see cref="TimeSpan"/>
        /// value less than <see cref="TimeSpan.MinValue"/> or greater
        /// than <see cref="TimeSpan.MaxValue"/>.
        /// </exception>
        public static string MillisecondsToCsTimerFormat(int milliseconds)
        {
            var time = new TimeSpan(0, 0, 0, 0, milliseconds);
            if (time.TotalHours > 1d) return (int)time.TotalHours + ":" + time.Minutes.ToString("D2") + ":" + time.Seconds.ToString("D2") + "." + time.Milliseconds.ToString("D3");
            if (time.Minutes != 0) return time.Minutes + ":" + time.Seconds.ToString("D2") + "." + time.Milliseconds.ToString("D3");
            return time.Seconds + "." + time.Milliseconds.ToString("D3");
        }

        /// <summary>
        /// Transform a string in the format of csTimer to a time in
        /// milliseconds.
        /// </summary>
        /// <remarks>
        /// <para>csTimer uses the format HH:MM:SS.mmm.</para>
        /// Use <seealso cref="MillisecondsToCsTimerFormat(int)"/> to
        /// transform time in milliseconds to a string.
        /// </remarks>
        /// <param name="time">
        /// The time as string to be transformed
        /// </param>
        /// <returns>The time in milliseconds</returns>
        /// <exception cref="ArgumentNullException">
        /// Thrown if <paramref name="time"/> is null.
        /// </exception>
        /// <exception cref="FormatException">
        /// Thrown if <paramref name="time"/> has an invalid format.
        /// </exception>
        public static int CsTimerFormatToMilliseconds(string time)
        {
            if (time is null)
                throw new ArgumentNullException(nameof(time) + " is null.");
            int hours = 0;
            try
            {
                if (time.Length > 9) //necessary because TimeSpan throws an OverflowException if there are more than 23 hours
                {
                    var splitTime = time.Split(new[] { ':' }, 2);
                    hours = int.Parse(splitTime[0]);
                    time = splitTime[1];
                }
                return (int) TimeSpan.ParseExact(time, new[] { @"m\:ss\.fff", @"s\.fff", @"m\:ss\.ff", @"s\.ff", @"m\:ss\.f", @"s\.f" }, CultureInfo.InvariantCulture).TotalMilliseconds + hours* 3_600_000;
            }
            catch (Exception exception)
            {
                if (exception is FormatException || exception is OverflowException)
                    throw new FormatException(nameof(time) + " has an invalid format: " + time);
                else
                    throw;
            }
        }

        /// <summary>
        /// Get the string representation of the data in the format of a line
        /// in a csTimer CSV file.
        /// </summary>
        /// <remarks>
        /// See <seealso cref="ToString(string)"/> for specifying the
        /// separator.
        /// </remarks>
        /// <returns>The string representation of the data.</returns>
        /// <exception cref="FormatException">
        /// Thrown if <see cref="Milliseconds"/> specifies a
        /// <see cref="TimeSpan"/> value less than
        /// <see cref="TimeSpan.MinValue"/> or greater than
        /// <see cref="TimeSpan.MaxValue"/>.
        /// </exception>
        public override string ToString()
             => this.ToString(";");

        /// <summary>
        /// Get the string representation of the data in the format of a line
        /// in a csTimer CSV file. The separator has to be specified.
        /// </summary>
        /// <returns>The string representation of the data.</returns>
        /// <exception cref="ArgumentNullException">
        /// Thrown if separator is null.
        /// </exception>
        /// <exception cref="FormatException">
        /// Thrown if <see cref="Milliseconds"/> specifies a
        /// <see cref="TimeSpan"/> value less than
        /// <see cref="TimeSpan.MinValue"/> or greater than
        /// <see cref="TimeSpan.MaxValue"/>.
        /// </exception>
        public string ToString(string separator)
        {
            if (separator is null)
                throw new ArgumentNullException(nameof(separator) + " is null.");

            return
                Number + separator + //No.
                CombineTimeAndPenalty(Milliseconds, Penalty) + separator + //Time
                (Comment ?? "") + separator + //Time
                (Scramble ?? "") + separator + //Comment
                (Date is null ? "N/A" : Date.Value.ToString("yyyy-MM-dd HH:mm:ss")) + separator + //Date
                MillisecondsToCsTimerFormat(Milliseconds); //Splits
        }
    }
}